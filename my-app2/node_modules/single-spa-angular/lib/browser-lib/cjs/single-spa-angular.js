'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@angular/core');
var common = require('@angular/common');
var platformBrowser = require('@angular/platform-browser');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

var SingleSpaPlatformLocation = /** @class */ (function (_super) {
    __extends(SingleSpaPlatformLocation, _super);
    function SingleSpaPlatformLocation() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // This is a simple marker that helps us to ignore PopStateEvents
        // that was not dispatched by the browser.
        _this.skipNextPopState = false;
        _this.onPopStateListeners = [];
        return _this;
    }
    SingleSpaPlatformLocation.prototype.destroy = function () {
        // TLDR: Angular adds `popstate` event listener and then doesn't remove it when application gets destroyed.
        // Basically, Angular has a potentional memory leak. The `ɵBrowserPlatformLocation`
        // has `onPopState` method which adds `popstate` event listener and forgets, see here:
        // https://github.com/angular/angular/blob/14be55c9facf3e47b8c97df4502dc3f0f897da03/packages/common/src/location/platform_location.ts#L126
        for (var _i = 0, _a = this.onPopStateListeners; _i < _a.length; _i++) {
            var onPopStateListener = _a[_i];
            window.removeEventListener('popstate', onPopStateListener);
        }
        // We do this because the `SingleSpaPlatformLocation` is a part of PLATFORM_INJECTOR,
        // which means it's created only once and will not be garbage collected, since the PLATFORM_INJECTOR
        // will keep reference to its instance.
        this.onPopStateListeners = [];
    };
    SingleSpaPlatformLocation.prototype.pushState = function (state, title, url) {
        this.skipNextPopState = true;
        _super.prototype.pushState.call(this, state, title, url);
    };
    SingleSpaPlatformLocation.prototype.replaceState = function (state, title, url) {
        this.skipNextPopState = true;
        _super.prototype.replaceState.call(this, state, title, url);
    };
    SingleSpaPlatformLocation.prototype.onPopState = function (fn) {
        var _this = this;
        var onPopStateListener = function (event) {
            if (_this.skipNextPopState) {
                _this.skipNextPopState = false;
            }
            else {
                // Wrap any event listener into zone that is specific to some application.
                // The main issue is `back/forward` buttons of browsers, because they invoke
                // `history.back|forward` which dispatch `popstate` event. Since `single-spa`
                // overrides `history.replaceState` Angular's zone cannot intercept this event.
                // Only the root zone is able to intercept all events.
                // See https://github.com/single-spa/single-spa-angular/issues/94 for more details
                _this.ngZone.run(function () { return fn(event); });
            }
        };
        // All listeners should be stored inside an array because the `onPopState` can be called
        // multiple times thus we wanna reference all listeners to remove them further.
        this.onPopStateListeners.push(onPopStateListener);
        _super.prototype.onPopState.call(this, onPopStateListener);
    };
    SingleSpaPlatformLocation.prototype.setNgZone = function (ngZone) {
        this.ngZone = ngZone;
    };
    SingleSpaPlatformLocation = __decorate([
        core.Injectable()
    ], SingleSpaPlatformLocation);
    return SingleSpaPlatformLocation;
}(platformBrowser.ɵBrowserPlatformLocation));
/**
 * The `PlatformLocation` class is an "injectee" of the `PathLocationStrategy`,
 * which creates `Subject` internally for listening on `popstate` events. We want
 * to provide this class in the most top injector that's used during bootstrapping.
 */
function getSingleSpaExtraProviders() {
    return [
        {
            provide: SingleSpaPlatformLocation,
            useClass: SingleSpaPlatformLocation,
            deps: [[new core.Inject(common.DOCUMENT)]],
        },
        {
            provide: common.PlatformLocation,
            useExisting: SingleSpaPlatformLocation,
        },
    ];
}

var defaultOpts = {
    // required opts
    NgZone: null,
    bootstrapFunction: null,
    template: null,
    // optional opts
    Router: undefined,
    domElementGetter: undefined,
    AnimationEngine: undefined,
    updateFunction: function () { return Promise.resolve(); }
};
function singleSpaAngular(userOpts) {
    if (typeof userOpts !== "object") {
        throw Error("single-spa-angular requires a configuration object");
    }
    var opts = __assign({}, defaultOpts, userOpts);
    if (typeof opts.bootstrapFunction !== 'function') {
        throw Error("single-spa-angular must be passed an opts.bootstrapFunction");
    }
    if (typeof opts.template !== "string") {
        throw Error("single-spa-angular must be passed opts.template string");
    }
    if (!opts.NgZone) {
        throw Error("single-spa-angular must be passed the NgZone opt");
    }
    return {
        bootstrap: bootstrap.bind(null, opts),
        mount: mount.bind(null, opts),
        unmount: unmount.bind(null, opts),
        update: opts.updateFunction
    };
}
function bootstrap(opts, props) {
    return Promise.resolve().then(function () {
        // In order for multiple Angular apps to work concurrently on a page, they each need a unique identifier.
        opts.zoneIdentifier = "single-spa-angular:" + (props.name || props.appName);
        // This is a hack, since NgZone doesn't allow you to configure the property that identifies your zone.
        // See https://github.com/PlaceMe-SAS/single-spa-angular-cli/issues/33,
        // https://github.com/single-spa/single-spa-angular/issues/47,
        // https://github.com/angular/angular/blob/a14dc2d7a4821a19f20a9547053a5734798f541e/packages/core/src/zone/ng_zone.ts#L144,
        // and https://github.com/angular/angular/blob/a14dc2d7a4821a19f20a9547053a5734798f541e/packages/core/src/zone/ng_zone.ts#L257
        opts.NgZone.isInAngularZone = function () {
            // @ts-ignore
            return window.Zone.current._properties[opts.zoneIdentifier] === true;
        };
        opts.routingEventListener = function () {
            opts.bootstrappedNgZone.run(function () {
                // See https://github.com/single-spa/single-spa-angular/issues/86
                // Zone is unaware of the single-spa navigation change and so Angular change detection doesn't work
                // unless we tell Zone that something happened
            });
        };
    });
}
function mount(opts, props) {
    return Promise
        .resolve()
        .then(function () {
        var domElementGetter = chooseDomElementGetter(opts, props);
        if (!domElementGetter) {
            throw Error("cannot mount angular application '" + (props.name || props.appName) + "' without a domElementGetter provided either as an opt or a prop");
        }
        var containerEl = getContainerEl(domElementGetter);
        containerEl.innerHTML = opts.template;
        var bootstrapPromise = opts.bootstrapFunction(props);
        if (!(bootstrapPromise instanceof Promise)) {
            throw Error("single-spa-angular: the opts.bootstrapFunction must return a promise, but instead returned a '" + typeof bootstrapPromise + "' that is not a Promise");
        }
        return bootstrapPromise.then(function (module) {
            if (!module || typeof module.destroy !== 'function') {
                throw Error("single-spa-angular: the opts.bootstrapFunction returned a promise that did not resolve with a valid Angular module. Did you call platformBrowserDynamic().bootstrapModule() correctly?");
            }
            var singleSpaPlatformLocation = module.injector.get(SingleSpaPlatformLocation, null);
            // The user has to provide `BrowserPlatformLocation` only if his application uses routing.
            // So if he provided `Router` but didn't provide `BrowserPlatformLocation` then we have to inform him.
            if (opts.Router && singleSpaPlatformLocation === null) {
                throw new Error("\t\n            single-spa-angular: could not retrieve extra providers from the platform injector. Did you call platformBrowserDynamic(getSingleSpaExtraProviders()).bootstrapModule() when creating platform?\t\n          ");
            }
            var ngZone = module.injector.get(opts.NgZone);
            if (singleSpaPlatformLocation !== null) {
                singleSpaPlatformLocation.setNgZone(ngZone);
                // Cleanup resources, especially remove event listeners thus they will not be added
                // twice when application gets bootstrapped the second time.
                module.onDestroy(function () { return singleSpaPlatformLocation.destroy(); });
            }
            opts.bootstrappedNgZone = ngZone;
            opts.bootstrappedNgZone._inner._properties[opts.zoneIdentifier] = true;
            window.addEventListener('single-spa:routing-event', opts.routingEventListener);
            opts.bootstrappedModule = module;
            return module;
        });
    });
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function unmount(opts, props) {
    return Promise.resolve().then(function () {
        if (opts.Router) {
            // Workaround for https://github.com/angular/angular/issues/19079
            var routerRef = opts.bootstrappedModule.injector.get(opts.Router);
            routerRef.dispose();
        }
        window.removeEventListener('single-spa:routing-event', opts.routingEventListener);
        opts.bootstrappedModule.destroy();
        if (opts.AnimationEngine) {
            /*
            The BrowserAnimationsModule does not clean up after itself :'(. When you unmount/destroy the main module, the
            BrowserAnimationsModule uses an AnimationRenderer thing to remove dom elements from the page. But the AnimationRenderer
            defers the actual work to the TransitionAnimationEngine to do this, and the TransitionAnimationEngine doesn't actually
            remove the dom node, but just calls "markElementAsRemoved()".
      
            See https://github.com/angular/angular/blob/db62ccf9eb46ee89366ade586365ea027bb93eb1/packages/animations/browser/src/render/transition_animation_engine.ts#L717
      
            What markAsRemovedDoes is put it into an array called "collectedLeaveElements", which is all the elements that should be removed
            after the DOM has had a chance to do any animations.
      
            See https://github.com/angular/angular/blob/master/packages/animations/browser/src/render/transition_animation_engine.ts#L525
      
            The actual dom nodes aren't removed until the TransitionAnimationEngine "flushes".
      
            See https://github.com/angular/angular/blob/db62ccf9eb46ee89366ade586365ea027bb93eb1/packages/animations/browser/src/render/transition_animation_engine.ts#L851
      
            Unfortunately, though, that "flush" will never happen, since the entire module is being destroyed and there will be no more flushes.
            So what we do in this code is force one more flush of the animations after the module is destroyed.
      
            Ideally, we would do this by getting the TransitionAnimationEngine directly and flushing it. Unfortunately, though, it's private class
            that cannot be imported and is not provided to the dependency injector. So, instead, we get its wrapper class, AnimationEngine, and then
            access its private variable reference to the TransitionAnimationEngine so that we can call flush.
            */
            var animationEngine = opts.bootstrappedModule.injector.get(opts.AnimationEngine);
            animationEngine._transitionEngine.flush();
        }
        delete opts.bootstrappedModule;
    });
}
function getContainerEl(domElementGetter) {
    var element = domElementGetter();
    if (!element) {
        throw Error("domElementGetter did not return a valid dom element");
    }
    return element;
}
function chooseDomElementGetter(opts, props) {
    props = props && props.customProps ? props.customProps : props;
    if (props.domElement) {
        return function () { return props.domElement; };
    }
    else if (props.domElementGetter) {
        return props.domElementGetter;
    }
    else if (opts.domElementGetter) {
        return opts.domElementGetter;
    }
    else {
        return defaultDomElementGetter(props.name);
    }
}
function defaultDomElementGetter(name) {
    return function getDefaultDomElement() {
        var id = "single-spa-application:" + name;
        var domElement = document.getElementById(id);
        if (!domElement) {
            domElement = document.createElement('div');
            domElement.id = id;
            document.body.appendChild(domElement);
        }
        return domElement;
    };
}

exports.default = singleSpaAngular;
exports.getSingleSpaExtraProviders = getSingleSpaExtraProviders;
